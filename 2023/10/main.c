#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include <ctype.h>

#include "../helper.h"

#define GRID_ROWS 140
#define GRID_COLUMNS 142 // +1 because of the null terminator.

// Directions: north, south, east, west
int row_directions[] = {-1, 1, 0, 0};
int col_directions[] = {0, 0, 1, -1};

// Checks if a position is within grid bounds.
bool is_valid(int row, int col)
{
    return row >= 0 && row < GRID_ROWS && col >= 0 && col < GRID_COLUMNS;
}

// Check if two pipes connect
// This was kindly generated by ChatGPT, props!
bool can_connect(char current, char next, int direction)
{
    if (direction == 0) // Moving north
    {
        if (current == '|' || current == 'J' || current == 'L' || current == 'S') {
            return next == '|' || next == '7' || next == 'F' || next == 'S';
        }
    }
    else if (direction == 1) // Moving south
    {
        if (current == '|' || current == '7' || current == 'F' || current == 'S')
        {
            return next == '|' || next == 'L' || next == 'J' || next == 'S';
        }
    }
    else if (direction == 2) // Moving east
    {
        if (current == '-' || current == 'F' || current == 'L' || current == 'S')
        {
            return next == '-' || next == '7' || next == 'J' || next == 'S';
        }
    }
    else if (direction == 3) // Moving west
    {
        if (current == '-' || current == '7' || current == 'J' || current == 'S')
        {
            return next == '-' || next == 'F' || next == 'L' || next == 'S';
        }
    }

    return false;
}

// BFS strikes again!
int bfs(char grid[GRID_ROWS][GRID_COLUMNS], int start_row, int start_col)
{
    int queue[GRID_ROWS * GRID_COLUMNS][2];
    int current = 0, next = 0;

    // Distance grid to store distances from the start point
    int distances[GRID_ROWS][GRID_COLUMNS] = {0};
    bool visited[GRID_ROWS][GRID_COLUMNS] = {false};

    // Enqueue the start position
    queue[next][0] = start_row;
    queue[next][1] = start_col;
    next++;
    visited[start_row][start_col] = true;

    int max_distance = 0;

    // Process the BFS
    while (current < next)
    {
        int current_row = queue[current][0];
        int current_col = queue[current][1];
        current++;

        // Check all 4 possible directions (north, south, east, west)
        for (int i = 0; i < 4; i++)
        {
            int new_row = current_row + row_directions[i];
            int new_col = current_col + col_directions[i];

            if (is_valid(new_row, new_col) && can_connect(grid[current_row][current_col], grid[new_row][new_col], i) && !visited[new_row][new_col])
            {
                // Mark as visited and update the distance
                visited[new_row][new_col] = true;
                distances[new_row][new_col] = distances[current_row][current_col] + 1;
                max_distance = distances[new_row][new_col];
                
                // Enqueue the new position
                queue[next][0] = new_row;
                queue[next][1] = new_col;
                next++;
            }
        }
    }

    return max_distance;
}

int part_1(char **file_content)
{
    char grid[GRID_ROWS][GRID_COLUMNS];

    for (int i = 0; file_content[i] != NULL; i++)
    {
        strncpy(grid[i], file_content[i], GRID_COLUMNS);
        grid[i][GRID_COLUMNS] = '\0';
    }

    // Find starting position
    int start_row, start_column = 0;
    for (int r = 0; r < GRID_ROWS; r++)
    {
        for (int c = 0; c < GRID_COLUMNS; c++)
        {
            if (grid[r][c] == 'S')
            {
                start_row = r;
                start_column = c;
                break;
            }
        }
    }

    int result = bfs(grid, start_row, start_column);

    return result;
}

int main()
{
    FILE *fptr = fopen("input.txt", "r");
    char **file_content = read_file(fptr);

    if (file_content == NULL)
    {
        return 1;
    }

    printf("Part 1: %d\n", part_1(file_content));
    // printf("Part 2: %ld\n", part_2(file_content));
}
