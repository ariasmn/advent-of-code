#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include <ctype.h>

#include "../helper.h"

#define GRID_ROWS 140
#define GRID_COLUMNS 142 // +1 because of the null terminator.

// Directions: north, south, east, west
int row_directions[] = {-1, 1, 0, 0};
int col_directions[] = {0, 0, 1, -1};

// Checks if a position is within grid bounds.
bool is_valid(int row, int col)
{
    return row >= 0 && row < GRID_ROWS && col >= 0 && col < GRID_COLUMNS;
}

// Check if two pipes connect
// This was kindly generated by ChatGPT, props!
bool can_connect(char current, char next, int direction)
{
    if (direction == 0) // Moving north
    {
        if (current == '|' || current == 'J' || current == 'L' || current == 'S')
        {
            return next == '|' || next == '7' || next == 'F' || next == 'S';
        }
    }
    else if (direction == 1) // Moving south
    {
        if (current == '|' || current == '7' || current == 'F' || current == 'S')
        {
            return next == '|' || next == 'L' || next == 'J' || next == 'S';
        }
    }
    else if (direction == 2) // Moving east
    {
        if (current == '-' || current == 'F' || current == 'L' || current == 'S')
        {
            return next == '-' || next == '7' || next == 'J' || next == 'S';
        }
    }
    else if (direction == 3) // Moving west
    {
        if (current == '-' || current == '7' || current == 'J' || current == 'S')
        {
            return next == '-' || next == 'F' || next == 'L' || next == 'S';
        }
    }

    return false;
}

// BFS strikes again!
int bfs(char grid[GRID_ROWS][GRID_COLUMNS], int start_row, int start_col, bool visited[GRID_ROWS][GRID_COLUMNS])
{
    int queue[GRID_ROWS * GRID_COLUMNS][2];
    int current = 0, next = 0;

    // Distance grid to store distances from the start point
    int distances[GRID_ROWS][GRID_COLUMNS] = {0};

    // Enqueue the start position
    queue[next][0] = start_row;
    queue[next][1] = start_col;
    next++;
    visited[start_row][start_col] = true;

    int max_distance = 0;

    // Process the BFS
    while (current < next)
    {
        int current_row = queue[current][0];
        int current_col = queue[current][1];
        current++;

        // Check all 4 possible directions (north, south, east, west)
        for (int i = 0; i < 4; i++)
        {
            int new_row = current_row + row_directions[i];
            int new_col = current_col + col_directions[i];

            if (is_valid(new_row, new_col) && can_connect(grid[current_row][current_col], grid[new_row][new_col], i) && !visited[new_row][new_col])
            {
                // Mark as visited and update the distance
                visited[new_row][new_col] = true;
                distances[new_row][new_col] = distances[current_row][current_col] + 1;
                max_distance = distances[new_row][new_col];

                // Enqueue the new position
                queue[next][0] = new_row;
                queue[next][1] = new_col;
                next++;
            }
        }
    }

    return max_distance;
}

int part_1(char **file_content)
{
    char grid[GRID_ROWS][GRID_COLUMNS];
    bool visited[GRID_ROWS][GRID_COLUMNS] = {false};

    for (int i = 0; file_content[i] != NULL; i++)
    {
        strncpy(grid[i], file_content[i], GRID_COLUMNS);
        grid[i][GRID_COLUMNS] = '\0';
    }

    // Find starting position
    int start_row, start_column = 0;
    for (int r = 0; r < GRID_ROWS; r++)
    {
        for (int c = 0; c < GRID_COLUMNS; c++)
        {
            if (grid[r][c] == 'S')
            {
                start_row = r;
                start_column = c;
                break;
            }
        }
    }

    int result = bfs(grid, start_row, start_column, visited);

    return result;
}

// This was way hard for me so again, had to look up solutions.
// First tried to do the Flood Fill algorithm, which looked easy. Manage to correctly do all the test inputs,
// but something was wrong using the big input, and debugging was getting harder.
// Then, I saw some discussions about solving it using Ray Casting,
// which is an amazing and simple algorithm (and shame on my side that didn't know about it)
// The idea here is to:
// Trace the way using the part 1 approach (BFS), to see what coords are inside and what are outside.
// Then, use the Ray Casting algorithm to check which points are inside and which outside.
int part_2(char **file_content)
{
    char grid[GRID_ROWS][GRID_COLUMNS];
    bool visited[GRID_ROWS][GRID_COLUMNS] = {false};

    for (int i = 0; i < GRID_ROWS; i++)
    {
        strncpy(grid[i], file_content[i], GRID_COLUMNS - 1);
        grid[i][GRID_COLUMNS - 1] = '\0';
    }

    int start_row = 0, start_column = 0;
    for (int r = 0; r < GRID_ROWS; r++)
    {
        for (int c = 0; c < GRID_COLUMNS - 1; c++)
        {
            if (grid[r][c] == 'S')
            {
                start_row = r;
                start_column = c;
                break;
            }
        }
        if (start_row != 0) break;
    }

    // Use BFS to trace the visited
    // Bit of cheating here, since I adapted the BFS function to receive the visited bool array
    // instead of creating it inside the function so it gets modified and used here, to avoid code duplication.
    // I know, not the cleanest, but honestly got kind of tired of this problem, so here it is.
    bfs(grid, start_row, start_column, visited);

    // Count enclosed tiles using ray casting algorithm
    int enclosed_tiles = 0;
    for (int r = 0; r < GRID_ROWS; r++)
    {
        int crossings = 0;
        char last_turn = '\0';
        for (int c = 0; c < GRID_COLUMNS - 1; c++)
        {
            if (visited[r][c])
            {
                char current = grid[r][c];
                if (current == '|' || current == 'S')
                {
                    crossings++;
                }
                else if (current == 'L' || current == 'F')
                {
                    last_turn = current;
                }
                else if ((current == '7' && last_turn == 'L') || (current == 'J' && last_turn == 'F'))
                {
                    crossings++;
                }
            }
            else if (crossings % 2 == 1)
            {
                enclosed_tiles++;
            }
        }
    }

    return enclosed_tiles;
}

int main()
{
    FILE *fptr = fopen("input.txt", "r");
    char **file_content = read_file(fptr);

    if (file_content == NULL)
    {
        return 1;
    }

    printf("Part 1: %d\n", part_1(file_content));
    printf("Part 2: %d\n", part_2(file_content));
}
